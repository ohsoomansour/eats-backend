/* eslint-disable prettier/prettier */
import { ApolloDriver } from '@nestjs/apollo';
import * as Joi from 'joi';
import { Module } from '@nestjs/common';
import { GraphQLModule } from '@nestjs/graphql';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ConfigModule } from '@nestjs/config';
import { UsersModule } from './users/uers.module';
import { User } from './users/entities/user.entity';
import { JwtModule } from './jwt/jwt.module';
import { Verification } from './users/entities/verification.entity';
import { MailModule } from './mail/mail.module';
import { Restaurant } from './restaurants/entities/restaurant.entity';
import { Category } from './restaurants/entities/category.entity';
import { RestaurantsModule } from './restaurants/restaurants.module';
import { AuthModule } from './auth/auth.module';
import { Dish } from './restaurants/entities/dish.entity';
import { OrdersModule } from './orders/orders.module';
import { Order } from './orders/entities/order.entity';
import { OrderItem } from './orders/entities/order-item.entity';
import { CommonModule } from './common/common.module';
import { PaymentModule } from './payment/payment.module';
import { Payment } from './payment/entities/payment.entity';
import { ScheduleModule } from '@nestjs/schedule';
import { UploadsModule } from './uploads/uploads.module';
import { Context } from 'apollo-server-core';
/*#️⃣1.0 Appllo Server Setup
 1.설치: npm i @nestjs/graphql @nestjs/apollo graphql apollo-server-express
    > 이해:  graphql & appllo server 기반하여 작동 
 2. AppModule은 main.ts로 import되는 유일한 모듈    
 3. forRoot
  - '루트 모듈'을 설정하는 것 여기서는 ⭐GraphModule이 이다 
    > Error: Appllor Server requires either an existing 'schema', modules or 'typeDefs'
    > Error이유: graphql이 data의 shape을 미리 알고 있어야 하기 때문
        ⭐gql`
           (Schema Defination Language)
          1)query data에 대해서도 하나의 언어를 쓰고 data의 shape을 설명하는 데에도 같은 언어를 쓴다는 것  
          2)우리 data의 type에 대해 graphql한테 설명해주기 위해서 
          3)Query root type must be provided. 
  #️⃣1.1 Our First Resolver
  1. The GraphQLModule can be configured to use Apollo server "아폴로 서버 기반으로 동작한다 "
  2. https://www.apollographql.com/docs/apollo-server/api/apollo-server
    > API Reference: apollo-server 에서 세팅 확인

  3. Quick start - 🔷Code first
   - GraphQLModule.forRoot<ApolloDriverConfig>({
    ⭐driver: ApolloDriver,
    ⭐autoSchemaFile: join(process.cwd(), 'src/schema.gql'),  "자동으로 날 위해 'schema'를 생성 해준다 "
    }),                   


    > 🚨Missing "driver" option > ⭐driver: ApolloDriver,
    > 🚨에러 메세지: Query root type must be provided
      - Schema generation error (code-first approach)
      - 원인:
       [GraphQL > API Reference - ApploServer 참조]
        Document or documents that represent your server's GraphQL schema
        ,generated by applying the gql tag to valid Schema Definition Language (SDL) strings. 
        🔹const typeDefs = gql`
          type Query {}
        `
        🔹const server = new ApolloServer({typeDefs, resolvers});
        ⭐우리의 GraphQL 모듈이  Query root type와 resolver를 찾고 있다 
        > npx nest g mo restaurants 
        > [resaurants.module.ts] 생성이 될거고
          @Module({
          ⭐providers: [RestaurantResolver],
          })
          export class RestaurantsModule {}  
        > [restaurants.resolver.ts] 파일 직접 만들고 ⭐@Resolver & @Query 작성 
        > [schema.gql]파일 생성 후 삭제시, ⭐autoSchemaFile:true;
    4.http://localhost:3000/graphql 
      > playground & SCHEMA가 있다 
         
 */
/*#️⃣2.0 TypeORM and PostgreSQL
  1. 🛸TypeScript & NesJS에서 DataBase와 통신하기 위해서 > ⭐ORM 사용
  2. typeorm.io/#/ > TYPE ORM을 쓰면 타입스크립트의 좋은 점을 모두 이용
  3. TypeORM: Object Relational Mapping 객체 관계 매핑 
   > SQL문을 쓰는 대신에 코드를 써서 상호작용을 할 수 있다
   > 타입스크립트 코드 > TYPE ORM 🛸 데이터베이스와 상호작용 

  4.PostgreSQL: https://www.postgresql.org/ 
  📄 4-1)설치
   > C:\Program Files\PostgreSQL\11 > pw:2848 > port:3000 
   > postgresql-12.12-1-windows-x64.exe --install_runtimes 0
   >⭐PostgreSQL 11.2 설치방법 https://source-factory.tistory.com/22
   >⭐PostgreSQL 11.2  https://get.enterprisedb.com/postgresql/postgresql-11.2-1-windows-x64.exe
   > 설치경로: C:\Program Files\PostgreSQL\11\data
   >  port:5432

  📄 4-2)⭐서버에 연결 방법
   > pgAdmin 열기 >  > [Add New server]
      - ⭐[connection] > hostname: localhost > port:5432(default) > Maintenanace database: postgres(default) 
      - Username:postgres(default) 
      > password:284823
   > Database우클릭, Create > Database: 🔹nuber-eats > Owner: ohsoomansour
   > ⭐SQL: Create DATABASE "nuber-eats", OWNER = ohsoomansour 
   > 실행된다는 것만 알고 넘어감
   >

  5. TypeORM
   - 의미: TypeScript로 작성된 관계형 매퍼 라이브러리 SQL을 작
   > docs.nestjs.com/techniques/database
   > npm > https://www.npmjs.com/package/typeorm
   > npm install typeorm --save
   > ⭐npm install reflect-metadata --save
   > npm install @types/node --save-dev
   > npm install pg --save
   > npm install --save @nestjs/typeorm typeorm pg
   > npm install typeorm --save
   > Install a database driver: npm install pg --save

  6. 프로젝트 & 외부DB(PostgreSQL) 연결    
   - 코드에 직접쓰거나 ormconfig.json이라는 파일에 쓰는 방법 
   - port:  5432(PostgreSQL)
    
   - password: localhost면 안써도됨, ohsoomansour(2848)
   - synchronize:true, "데이터베이스를 너의 모듈의 현재상태로 마이그래이션(이동) 한다는 뜻 "
   - logging: true, "데이터베이스에서 무슨 일이 일어나는지 콘솔에 표시" 
    > ⭐npm run start:dev "아래의 SQL코드 보이면 성공"
    query: SELECT * FROM current_schema()
    query: SELECT version();
    query: START TRANSACTION
    query: SELECT * FROM "information_schema"."tables" WHERE "table_schema" = 'public' AND "table_name" = 'typeorm_metadata'
    query: COMMIT

  7. 🚨Error: listen EADDRINUSE: address already in use :::3000 +5ms
   - 이미 3000번 포트가 사용중이다 
   - 해결방안1. 서버를 다 끄거나 해결방안2.  백앤드port: 4000 5000 8000 
  
   */
/*#️⃣2.4 환경변수 파일(.env)을 node.js에서 이용하는 방법은
📄TS(npm): https://www.npmjs.com/package/dotenv
> ⭐dotenv라이브러리는 .env 파일에서 환경 변수를 로드하는데
> [node.js] node.js에서 🔹'환경변수'에 접근할 때는 🔹'process.env'라는 '내장 자바스크립트 객체'를 사용 
  - process는 전역객체 별도로 임포트 모듈이 없으며 어플리케이션 어디에서든 접근이 가능함
  
🔷예시 ⭐"db 모듈이 env.process 를 통해 환경변수 객체를 얻고  >> 서버에 연결"
  const db = require('db') 
   db.connect({
     host: process.env.DB_USER
     username: process.env.DB_USER,
     password: process.env.DB_PASS
       })
  *equire(): "모듈을 불러옴"
  *connect() 함수는 서버에 대한 연결을 설정하는 데 사용
  *환경변수: 어느 directory에서든지 프로그램을 실행 할 수있게 만듬 ※https://velog.io/@psj0810/%ED%99%98%EA%B2%BD%EB%B3%80%EC%88%98%EB%9E%80

 📄nestjs방법: "📁configuration mudule 이란걸 가지고 있음" ※https://docs.nestjs.com/techniques/configuration
 1. 설치: npm i --save @nestjs/config 
  - The @nestjs/config package internally uses dotenv
 2.ConfigModule.forRoot({
    isGlobal:true, "우리 app의 어디서나 'config 모듈'에 접근할 수 있다는 거 "
    envFilePath: ".env",  "우리 파일에서 .env 파일을 읽는다 "
    ignoreEnvFile: process.env.NODE_ENV === 'prod' "production 환경일 때는 configModule이 '환경변수 파일'을 무시 "
    > 환경변수는 다른 방법으로 얻을거임 
  })
  > [node.js, NODE_ENV 값을 설정]
    ⭐NODE_ENV(환경변수)는 현재 단계를 정해주는 '상수'일뿐: dev단계 ? 스테이징 단계 ? 프로덕션단계 ? 
      > 각 프레임워크(라이브러리)마다 환경변수 파일을 불러오는 순서가 공식문서에 있음 
        - OS가 window일 경우, set NODE_ENV = production  
        - OS가 Mac OS X 기준, export NODE_ENV = production
         
  > 환경을 설정하려면 npm i cross-env 
   - ⭐cross-env 패키지를 사용하면 동적으로 process.env 환경변수(가상변수)를 설정할 수 있게 해준다 (OS에 관계없이)
  > [package.json] start:dev 커맨드를 입력하면, .env.dev로 설정하고싶다 
                   test나 test:wath를 입력하면, .env.test로 설정하고 싶다 
                   start 커맨드를 입력하면, env.pro로 설정하고 싶다 

  > [package.json] "start:dev": "cross-env NODE_ENV=dev nest start --watch",
    - npm run start:dev (터미널) -> "(명시된)'cross-env'를 불러서 NODE_ENV라는 ⭐환경변수(가상변수)를 dev라고 지정"
  > .gitnore에 .env를 추가 
   # dotenv environment variable files
    .env
    .env.dev
    .env.test
   
  */
/*#️⃣2.6 Validating ConfigService
1. npm i joi
  > validationSchema: "스키마의 유효성 확인이라고 생각하면 됨"
*/
/*#️⃣3.3Recap
  ⭐TypeOrmModule.forRoot({ 
      entities: [Restaurant]
      logging: true  
    })
   > TypOrmModule이 Restaurant entity를 가지고 있기 때문에' Restaurant이 DB'가 되는 거다
   > logging: true "DB에서 돌아가는 모든 로그들을 확인 "
*/
/*#️⃣📃forRoot: https://docs.nestjs.com/modules
  🔴1. GraphQLModule.forRoot 메서드에 인수로 context를 넣으면 어떻게 인식이 되는 건가요 ?
          forRoot메서드의 이해가 부족해서 이해가 잘 안 되는거 같습니다
          GraphQLModule.forRoot({
          driver: ApolloDriver,
          autoSchemaFile: true,
          context:({ req }) => ({user: req['user'] })
        }),
2. 아니면 nestjs의 문법 그대로 이해를 해야 하는 건가요 ?
 >> ✅nico:  Yes, this is how you configure a module on NestJS
*/
/*#️⃣9.0 Setup part One
1. where do we set NODE_ENV as 'test' ? 📄https://jestjs.io/docs/en/environment-variables
 > Set to 'test' if it's not already set to something else.
2. 우리가 test명령으로 실행을 하게 되면 NODE_ENV는 test가 될 거다 
  > npm run test:e2e   ✅NODE_ENV = 'test'
  > envFilePath: '.env.test' 실행 
*/
/*#️⃣12.0 Subscriptions part One - Graphql Subscription ~ #️⃣12.1 Subscriptions part Two

  1.[GraphQL] subscripttions은 resolver에서 '변경사항'이나 '업데이트'를 수신 할 수 있게 해준다

  2. [orders.resolver.ts] 📄npmjs.com/package/graphql-subscriptions
    @Subscription(returns => String) 🔵"몇 가지 규칙이 있는데 그 규칙은 우리가 뭘 return 하는지에 따라 정해짐"
    hotPotatos() {
      return pusub.asyncIterator(triggers: 🔵우리가 기다리는 이벤트: "이벤트를 듣고 싶으면 이 Subscription쓰면 된다"
    }

   3. 
     PubSub은 publish and subscribe를 말한다  
      subscription{ 🔵HTTP route를 거치지 않고 Web Socket route를 거치고 있다
        hotPotatos
      }

   4. {
        "error": "Could not connect to websocket endpoint ✅ws://localhost:3000/graphql.
        Please check if the endpoint url is correct."
      }
      🔹ws: 프로토콜, 이것은 Real Time을 처리하는 'Web Socket'을 말한다 
       ✅Web Socket을 활성화 해야한다 
       GraphQLModule.forRoot({
       ✅installSubscriptionHandlers:true, ⭐서버가 웹 소켓 기능을 가지게 된다 
       }),
       🔴웹 소켓에는 'request'가 없다
       🔵웹 소켓에는 'conneection'이라는 것이 있다 
         
    5. connection은 'context'와 같이 온다  vs  request는 x-jwt header가 있다 
      🔹웹소켓: 'Connection'은 웹 소켓이 클라이언트와 서버 간의 연결을 설정하려고 할 때 발생한다 

     5-1) 
          [app.module.ts]
            context: ({req, connection}) => {
              if(req) {
                return { user: req['user'] };
              } else {
                return { potato: 'hot' }
            }


    5-2) guard는 'HTTP'이든 '웹 소켓'이든 모든 'graphQL resolver'에 대해 호출 된다
         [auth.guard.ts]
            const gqlContext = GqlExecutionContext.create(context).getContext();
            console.log(gqlContext ) //🚧{photato: 'hot', req: undefined}    
    5-3) [app.modul.ts]
        🔵사용자가 인증되었는지 확인하는 것은 subscriptions 옵션에서 지정할 수 있는 onConnect콜백 함수 내에서 수행 되어야 한다
        🔵onConnect는 첫 번째 인수로 SubscriptionClient(✅playground-HTTPHeader?)에 전달된 'connectionParams'를 받는다
          🔹클라이언트: 게임회사, 서버(컴퓨터)에서 업데이트 > 새로운 버전 업데이트를 내려받는 것을 클라이언트   
*/
/*#️⃣ dotenv & crossenv
   1. "start:dev": "cross-env NODE_ENV=dev nest start --watch",
      🚀.env.dev 파일을 실행시킨다 > ⚡process.env.DB_HOST 등 
      🔴.env.dev (기존)> .env.prod(확장자변경) > 🚧Config validation error: "DB_HOST" is required 등
*/
/*#️⃣13.2 Subscription Authentication part One 
1.🚧 'Web socket' - 'subscriptions-transport-ws' 🚧
   GraphQLModule.forRoot({
      driver: ApolloDriver,
      autoSchemaFile: true,
      subscriptions: {
        //🚨graphql-ws 권장! 📄https://docs.nestjs.com/graphql/subscriptions#subscriptions
        'subscriptions-transport-ws': {
          onConnect: (connectionParams) => {
          //console.log(connectionParams) //{"x-jwt":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MywiaWF0IjoxNjY0OTM5MzM2fQ.BV5myZA10vef-xz-zZRQWRGyvLNUNsdotPLUI_tNS7M"}
          const authToken = connectionParams['x-jwt'];
          if(!authToken){
            throw new Error('Token is  not valid')
          }
          const token = authToken;
          return {token} 
          },
        },
      },
      context: ({ req, connection }) => ({ token: req.headers['x-jwt'] }),
    }), 

  #️⃣25.1 Subscription Setup
  🚧 'Web Socekt': 'graphql-ws'🚧
    +📄Soujiro-a님: https://github.com/Soujiro-a/nuber-eats-backend/commit/ae04e5ac9a7acd7845cf7cbe02c72f73ce14806a 
    +📄Nest JS docs: https://docs.nestjs.com/graphql/subscriptions#authentication-over-websockets  
    +📄APOLLO docs:  https://www.apollographql.com/docs/react/data/subscriptions/#1-install-required-libraries

     프론트 엔드: npm install graphql-ws 설치 
*/

@Module({
  imports: [ 
    ConfigModule.forRoot({
      isGlobal:true,
      envFilePath: process.env.NODE_ENV === 'dev' ? '.env.dev' : '.env.test',
      ignoreEnvFile: process.env.NODE_ENV === 'prod',
      validationSchema: Joi.object({
        NODE_ENV: Joi.string()
          .valid('dev', 'prod', 'test')
          .required(),
        DB_HOST: Joi.string().required(),
        DB_PORT: Joi.string().required(),
        DB_USERNAME: Joi.string().required(),
        DB_PASSWORD: Joi.string().required(),
        DB_NAME: Joi.string().required(),
        PRIVATE_KEY: Joi.string().required(),
        MAILGUN_API_KEY: Joi.string().required(),
        MAILGUN_DOMAIN_NAME: Joi.string().required(),
        MALIGUN_FROM_EMAIL: Joi.string().required(),
        AWS_ACCESS_KEY: Joi.string().required(),
        AWS_ACCESS_SECRET_KEY: Joi.string().required(),
      }),
    }),
    TypeOrmModule.forRoot({
      type: 'postgres',
      host: process.env.DB_HOST,
      port: +process.env.DB_PORT,
      username: process.env.DB_USERNAME,
      password: process.env.DB_PASSWORD,
      database: process.env.DB_NAME,
      synchronize: process.env.NODE_ENV !== 'prod',
      logging: process.env.NODE_ENV !== 'prod' && process.env.NODE_ENV !== 'test',
      entities:[User, Verification, Restaurant, Category, Dish, Order, OrderItem, Payment ],
      
    }),
    GraphQLModule.forRoot({
      driver: ApolloDriver,
      autoSchemaFile: true,
      subscriptions: {
        'graphql-ws': {
          onConnect: (context: Context<any>) => {
          
          const {connectionParams, extra} = context;
          extra.token = connectionParams['x-jwt'] 
          },
        },
      },
      context: ({ req, extra}) => {
        //console.log(extra) 
        if(extra){
          return { token: extra.token }
        } else {
          return { token: req.headers['x-jwt']}
        }
      }
    }), 


    ScheduleModule.forRoot(),   
    JwtModule.forRoot({
      privateKey: process.env.PRIVATE_KEY
    }),

    MailModule.forRoot({
      apiKey: process.env.MAILGUN_API_KEY,
      domain: process.env.MAILGUN_DOMAIN_NAME,
      fromEmail: process.env.MALIGUN_FROM_EMAIL,

    }),
    AuthModule,
    UsersModule,
    RestaurantsModule,
    OrdersModule,
    CommonModule,
    PaymentModule,
    UploadsModule,
    
  ],
  controllers: [],
  providers: [],
})
/*#️⃣5.6 Middlewares in NestJS
1. ⭐"JwtMiddleware를 forRoutes()를 통해서 /graphql 경로(path)에 method가 POST인 경우에만 적용 "
   ⭐ nestjs에서는 어떤 routes에 middleware를 적용시킬지 지정할 수가 있다  
  MiddlewareConsumer.apply(🔹JwtMiddleware)
  >📃middleware class/function(=🔹JwtMiddleware) be attached to the passed routes.
2.⭐<모든 routes에 적용하는 방법>
  export class AppModule implements NestModule{
    configure(consumer: MiddlewareConsumer) {
      consumer.apply(JwtMiddleware).forRoutes({
        path: '*'
        method: RequestMethod.ALL
      }) 
    }
  }    
3.⭐</api를 제외하고 적용>
export class AppModule implements NestModule{
  configure(consumer: MiddlewareConsumer) {
    consumer.apply(JwtMiddleware).exclude({
      path:'/api',
      method: RequestMethod.ALL, 
    }) 
  }
}
4.⭐<일반적 사용>
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(JwtMiddleware)
      .forRoutes({ path: '/graphql', method: RequestMethod.POST });
  }
}
*/
export class AppModule {}
